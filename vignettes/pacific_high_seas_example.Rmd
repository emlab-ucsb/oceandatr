---
title: "Pacific High Seas Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pacific High Seas Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Along with `oceandatr` we will need to load `prioritizr` for the spatial prioritization and we will use the open source solver `lsymphony` to solve the prioritization problem, so this needs to be installed and loaded via th Bioconductor website 

```{r setup}
library(oceandatr)
library(gfwr)
library(prioritizr)
remotes::install_bioc("lpsymphony")
library(lpsymphony)
```

This example shows how to use `oceandatr` to create a complete set of feature data that can be used directly in a spatial prioritization. 

# High Seas area of the Pacific Ocean

First we retrieve the entire High Seas area, then we will crop for the area we are interested in, highlighted in red on the map.

```{r high_seas_area}
hs <- get_area(area_name = "63203", query_type = "high_seas", mregions_column = "mrgid")

pacific_hs_area_extent <- sf::st_bbox(c(xmin = 135, xmax = 155, ymin = 0, ymax = 6), crs = 4326)

plot(sf::st_geometry(hs), main = "High Seas", col = "royalblue3", axes = TRUE, las = 1)
plot(pacific_hs_area_extent %>% sf::st_as_sfc() %>% sf::st_cast(to = "LINESTRING"), col = "red", add = TRUE)
```

We are going to use only the highlighted Pacific High Seas area which borders Indonesia, Papua New Guinea, Palau and the Federated States of Micronesia. We can get the EEZs of these states using `oceandatr`'s `get_area` function.

```{r get_surrounding_eezs, message=FALSE}

country_names <- c("Indonesia", "Papua New Guinea", "Palau", "Micronesia")

eezs <- lapply(country_names, FUN = function(x) get_area(area_name = x) %>% dplyr::select(territory1) %>% dplyr::rename(name = territory1)) %>% 
  do.call(rbind, .) %>% 
  sf::st_cast(to = "MULTIPOLYGON")
```


```{r pacific_high_seas, message = FALSE, warning = FALSE}
sf::sf_use_s2(FALSE) #turn off S2 to avoid errors

pacific_hs <- hs %>% 
  sf::st_crop(pacific_hs_area_extent) %>% 
  dplyr::mutate(name = "Pacific High Seas area") %>% 
  dplyr::select(name)

sf::sf_use_s2(TRUE)

plot(rbind(sf::st_cast(pacific_hs, to = "MULTIPOLYGON"), eezs), axes = TRUE, las = 1, main = NULL, key.pos = 4)
```

Now we select a suitable projection for the area and a suitable resolution for the planning grid used for gridding the data. We can use [projection wizard](https://projectionwizard.org) to find an equal-area projection, entering the same extent coordinates we used to crop the high seas area (xmin = 135, xmax = 155, ymin = 0, ymax = 6). 

We will use 10km square planning units so that there the data processing and prioritization run reasonably fast (smaller planning units will require more time/ computer memory get data for)

```{r planning_grid}

pacific_hs_projection <- "+proj=cea +lon_0=145 +lat_ts=3 +datum=WGS84 +units=m +no_defs"

pacific_hs_planning_grid <- get_planning_grid(area_polygon = pacific_hs,
                                   projection_crs = pacific_hs_projection,
                                   resolution = 10000) 

#get_planning_grid returns a raster by default, so we can plot it using the terra package
terra::plot(pacific_hs_planning_grid, col = "grey70")
```

```{r include=FALSE}

pacific_hs_planning_grid_ras <- get_planning_grid(area_polygon = pacific_hs,
                                   projection_crs = pacific_hs_projection,
                                   resolution = 30000) 

pacific_hs_planning_grid_sf <- get_planning_grid(area_polygon = pacific_hs,
                                   projection_crs = pacific_hs_projection,
                                   option = "sf_hex",
                                   resolution = 30000)

pacific_hs_map <- ggplot2::ggplot(data = rbind(sf::st_cast(pacific_hs, to = "MULTIPOLYGON"), eezs)) +
  ggplot2::geom_sf(ggplot2::aes(fill = name)) +
  ggplot2::geom_sf(data = pacific_hs, fill = "transparent", col = "black", lwd = 0.4) +
  ggplot2::scale_fill_brewer(type = "qual", palette = "Set2") +
  ggplot2::labs(fill = NULL) +
  ggplot2::theme_bw()

pacific_pus_ras_map <- ggplot2::ggplot(data = pacific_hs_planning_grid_ras %>% terra::project("epsg:4326") %>%  terra::as.data.frame(xy = TRUE)) +
  ggplot2::geom_raster(ggplot2::aes(x = x, y = y, fill = layer), fill = "grey70") +
  ggplot2::coord_sf() +
  ggplot2::scale_y_continuous(labels = ~ paste0(.x, "°N")) +
  ggplot2::scale_x_continuous(labels = ~ paste0(.x, "°E")) +
  ggplot2::theme_bw() +
  ggplot2::theme(legend.position = "none",
                 axis.title = ggplot2::element_blank())


pacific_pus_sf_map <- ggplot2::ggplot(data = pacific_hs_planning_grid_sf) +
  ggplot2::geom_sf(ggplot2::aes(), col = "black") +
  ggplot2::theme_bw()


cowplot::plot_grid(pacific_hs_map, pacific_pus_ras_map, pacific_pus_sf_map, ncol = 1, labels = "auto", label_size = 12, rel_heights = c(1.5, 1, 1), rel_widths = c(2, 3, 3), align = "v", axis = "r ")
```

Now we have a planning grid, we can use get a basic set of features to use in a spatial prioritization with a single command, setting the seamount buffer to 30km:

```{r features, warning=FALSE}
feature_set <- get_features(planning_grid = pacific_hs_planning_grid, seamount_buffer = 30000)

terra::plot(feature_set, maxnl = terra::nlyr(feature_set), fun = function(x)terra::lines(pacific_hs %>% sf::st_transform(pacific_hs_projection))) #set maximum number of layers to plot to the same as the number of layers in the feature set
```

# Cost data: fishing effort

```{r fishing-effort, message=FALSE}
pacific_hs_geojson <- pacific_hs_area_extent %>% #use the larger area extent because using just the pacific_hs polygon results in a slightly truncated area
  sf::st_as_sfc() %>% 
  sf::st_as_sf() %>% 
  gfwr::sf_to_geojson()

fishing_effort <- gfwr::get_raster(spatial_resolution = 'low',
                                   temporal_resolution = 'yearly',
                                   group_by = 'gearType', 
                                   date_range = '2022-01-01,2022-12-31',
                                   region = pacific_hs_geojson,
                                   region_source = 'user_json')

total_annual_effort <- fishing_effort %>% 
  dplyr::group_by(Lat, Lon, `Time Range`) %>% 
  dplyr::summarise(total_effort = sum(`Apparent Fishing Hours`, na.rm = TRUE)) %>% 
  dplyr::ungroup() %>% 
  dplyr::select("Lon", "Lat", "total_effort") %>%
  terra::rast(type = "xyz", crs = "epsg:4326") %>% 
  terra::subst(NA, 0) %>% 
  oceandatr::data_to_planning_grid(planning_grid = pacific_hs_planning_grid,
                                   dat = .,
                                   name = "fishing_effort")

terra::plot(total_annual_effort, fun = terra::lines(pacific_hs %>% sf::st_transform(pacific_hs_projection)))
```

# Run a simple prioritization

Set targets of 20% for all features.

```{r prioritization, message = FALSE}
prob <- prioritizr::problem(x = total_annual_effort, features = feature_set) %>% 
  add_min_set_objective() %>% 
  add_relative_targets(0.2) %>% 
  add_boundary_penalties(penalty = 0.0001) %>% 
  add_binary_decisions() %>% 
  add_lpsymphony_solver(verbose = FALSE)

sol <- solve(prob)

terra::plot(sol, main = "Solution", axes = TRUE, 
            col = c("grey70", "green4"),
            type = "classes",
            levels = c("Not selected", "Selected"),
            fun = terra::lines(pacific_hs %>% sf::st_transform(pacific_hs_projection)))
```

