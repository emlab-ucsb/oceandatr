---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "1%"
)
devtools::load_all()

#figure output settings
h = 3.5
w = 3.5
ow = "400"
```

# offshoredatr

<!-- badges: start -->
<!-- badges: end -->

Offshoredatr aims to provide simple functions for creating data for conducting a spatial conservation prioritization for large scale areas of the ocean, specifically offshore areas.

## Installation

You can install the development version of offshoredatr from [GitHub](https://github.com/) with:

```{r, eval = FALSE}
if (!require(devtools)) install.packages("devtools")
devtools::install_github("emlab-ucsb/offshoredatr")
```

## Example of usage

```{r eval=FALSE}
#load offshoredatr package
library(offshoredatr)
```
```{r}
#load tmap package for making nice maps
library(tmap)
```

### Obtain an EEZ for an area of interest

This function pulls data for EEZs from the [Marine Gazetteer](https://marineregions.org/gazetteer.php) using the `mregions2` R package; the function is just a wrapper to make the process a bit simpler. It's very basic at the moment and will fail if it doesn't find an EEZ that matches the `country_name` specified, which is not necessarily the same as the country name you would expect! 

TO DO: make the name matching fuzzy

```{r area of interest, fig.height=h, fig.width=w, out.width=ow}
bermuda_eez <- get_eez(country_name = "bermudian")

#plot to check we have Bermuda's EEZ
tm_shape(bermuda_eez) +
  tm_polygons(col = "lightblue") +
  tm_graticules(lines = FALSE)
```

# Choose a CRS

Best practice is to use a local, equal area projection for all geospatial data for use in the prioritization. Finding a suitable projection can be tricky, but [projection wizard](https://projectionwizard.org) provides a handy tool. Standard projections used for countries can also be found at https://epsg.io/ by searching with country name. 

The bounding box coordinates for the area of interest can be used to generate the coordinate reference system (CRS) on [projection wizard](https://projectionwizard.org)

```{r}
sf::st_bbox(bermuda_eez)
```

The coordinates above should be entered as the 'Geographic extent' and the map should then have a box drawn around the bounding box of the area of interest. The projection can then be copied and pasted from the pop-up box when clicking on 'WKT'. The projeciton needs to be placed in quotation marks as follows:

```{r projection}
projection <- 'PROJCS["ProjWiz_Custom_Lambert_Azimuthal",
 GEOGCS["GCS_WGS_1984",
  DATUM["D_WGS_1984",
   SPHEROID["WGS_1984",6378137.0,298.257223563]],
  PRIMEM["Greenwich",0.0],
  UNIT["Degree",0.0174532925199433]],
 PROJECTION["Lambert_Azimuthal_Equal_Area"],
 PARAMETER["False_Easting",0.0],
 PARAMETER["False_Northing",0.0],
 PARAMETER["Central_Meridian",-64.5],
 PARAMETER["Latitude_Of_Origin",32],
 UNIT["Meter",1.0]]'
```


### Get a planning grid for the area of interest

A planning grid is needed for spatial prioritization. This divides the area of interest into grid cells. The `planning_grid` function will return a planning grid for the specified area of interest (polygon), projected into the coordinate refernce system specified, at the cell resolution specified in kilometres.

```{r planning grid, warning=FALSE, fig.height=h, fig.width=w, out.width=ow}
planning_grid <- get_planning_grid(area_polygon = bermuda_eez, projection_crs = projection, resolution_km = 5)

#project the eez into same projection as planning grid for plotting
bermuda_eez_projected <- sf::st_transform(bermuda_eez, crs = projection)

#plot the planning grid
tm_shape(bermuda_eez_projected) +
  tm_borders() +
  tm_shape(planning_grid) +
  tm_raster(title = "Planning grid") + 
  tm_graticules(lines = FALSE)
```

The raster covers Bermuda's EEZ. The grid cells would be too small to see if we plotted them, but here is a coarser grid (lower resolution) visualized so we can see what the grid cells look like.

```{r planning grid cells, fig.height=h, fig.width=w, out.width=ow}
planning_grid_coarse <- get_planning_grid(area_polygon = bermuda_eez, projection_crs = projection, resolution_km = 20)

tm_shape(bermuda_eez_projected) +
  tm_borders() +
  tm_shape(raster::rasterToPolygons(planning_grid_coarse, dissolve = FALSE)) +
  tm_borders() +
  tm_graticules(lines = FALSE)
```

### Get bathymetry for area of interest

Now we have our planning grid, we can get data for this area of interest. A key piece of data is bathymetry. If the user has downloaded data for the area of interest from the [GEBCO website](https://www.gebco.net), they can pass the file path to this function and it will crop and rasterize the data using the supplied planning grid. If no file path is provided, the function will extract bathymetry data for the area from the [ETOPO 2022 Global Relief model](https://www.ncei.noaa.gov/products/etopo-global-relief-model) using a function borrowed from the `marmap` package.

```{r bathymetry, fig.height=h, fig.width=w, out.width=ow}
bathymetry <- get_bathymetry(area_polygon = bermuda_eez, planning_grid = planning_grid, keep = FALSE)

tm_shape(bathymetry) +
  tm_raster(palette = "Blues", title = "Depth (m)") +
  tm_shape(bermuda_eez_projected) +
  tm_borders() +
  tm_graticules(lines = FALSE)
```

### Depth classification

The ocean can be classified into 5 depth zones:

* 0 - 200m: Epipelagic zone
* 200 - 1000m: Mesopelagic zone
* 1000 - 4000m: Bathypelagic zone
* 4000 - 6000m: Abyssopelagic zone
* 6000m+: Hadopelagic zone

We can use these depth zone definitions to classify the bathymetry we just obtained into depth zones based on the ocean floor depths.

```{r depth classification, fig.height=h, fig.width=w, out.width=ow}
depth_zones <- classify_depths(bathymetry, planning_grid)

tm_shape(depth_zones) +
  tm_raster(palette = "blue4", legend.show = FALSE) +
  tm_shape(bermuda_eez_projected) +
  tm_borders() +
  tm_graticules(lines = FALSE)
```

### Get geomorphological data for area of interest

The seafloor has its own mountains, plains and other geomorphological features just as on land. These data come from [Harris et al. 2014, Geomorphology of the Oceans](https://doi.org/10.1016/j.margeo.2014.01.011) and are available for download from https://www.bluehabitats.org. The features that are suggested as major habitats for inclusion in no-take MPAs by [Ceccarelli et al. 2021](https://doi.org/10.3389/fmars.2021.634574) are included in this package, so it is not necessary to download them.

```{r geomorphology, warning=FALSE, message=FALSE, fig.height=h, fig.width=w, out.width=ow}
geomorphology <- get_geomorphology(area_polygon = bermuda_eez, planning_grid = planning_grid)

tm_shape(geomorphology) +
  tm_raster(palette = "sienna2", legend.show = FALSE) +
  tm_shape(bermuda_eez_projected) +
  tm_borders() +
  tm_graticules(lines = FALSE)
```




```{r pressure, echo = FALSE, include=FALSE}
## REMINDER FOR ME, WILL DELETE:

# You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this. You could also use GitHub Actions to re-render `README.Rmd` every time you push. An example workflow can be found here: <https://github.com/r-lib/actions/tree/v1/examples>.
# 
# You can also embed plots, for example:

#plot(pressure)

#In that case, don't forget to commit and push the resulting figure files, so they display on GitHub and CRAN.
```


