#' Classify bathymetry data into depth zones
#'
#' @description This function takes a bathymetric raster (depths must be negative and in meters) and reclassifies depths to categorical depth zones. If geospatial data are not in the appropriate coordinate reference system, users can specify a planning grid to reproject the bathymetry data. 
#' 
#' @details The depth groups are categorized as follows: 
#' \itemize{
#' \item Epipelagic Zone: 0-200 m depth
#' \item Mesopelagic Zone: 200-1000 m depth
#' \item Bathypelagic Zone: 1000-4000 m depth
#' \item Abyssopelagic Zone: 4000-6000 m depth
#' \item Hadopelagic Zone: 6000+ m depth
#' }
#' 
#' @param bathymetry_raster a raster of bathymetry data (meters) that you wish to categorize; depths must be negative
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#'
#' @return A raster of depth zones, rasterized to the planning grid resolution and CRS if supplied.
#' @export 
#'
#' @examples 
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda")
#' # Grab bathymetry data
#' bathymetry <- get_bathymetry(area_polygon = bermuda_eez)
#' # Classify depths 
#' depth_zones <- classify_depths(bathymetry)
#' depth_zones
classify_depths <- function(bathymetry){
  
  depth_zones <- c("hadopelagic", "abyssopelagic", "bathypelagic", "mesopelagic", "epipelagic" )
  
  bathymetry_cuts <- c(-12000, -6000, -4000, -1000, -200, 10)
  
  #get only the depth zone names needed for this classification
  depth_zone_names <- if(check_raster(bathymetry)) depth_zones[global(bathymetry, min, na.rm=TRUE)[1,1] < bathymetry_cuts[2:6]] else depth_zones[min(bathymetry[[1]]) < bathymetry_cuts[2:6]] 
  
  bathymetry_cuts <- bathymetry_cuts[(6-length(depth_zone_names)):6]
  
  # Run classification
  if(round(terra::ext(bathymetry_raster)[1]) <= -180 & round(terra::ext(bathymetry_raster)[2]) >= 180) { 
      message("Data cross the antimeridian - completing this step in two parts") 
      data_halves <- split_by_antimeridian(bathymetry_raster)
      message("Processing first half...")
      left_side <- classify_layers(data_halves[[1]], 
                                   planning_grid = planning_grid, 
                                   classification_matrix = bathymetry_matrix, 
                                   classification_names = depth_zone_names)
      message("Processing second half...")
      right_side <- classify_layers(data_halves[[2]], 
                                    planning_grid = planning_grid, 
                                    classification_matrix = bathymetry_matrix, 
                                    classification_names = depth_zone_names)
      depth_zones_stack <- combine_antimeridian(data = list(left_side, right_side), 
                                         planning_grid = planning_grid, 
                                         classification_names = depth_zone_names)
    } else {
      depth_zones_stack <- classify_layers(data = bathymetry_raster, 
                                           planning_grid = planning_grid, 
                                           classification_matrix = bathymetry_matrix, 
                                           classification_names = depth_zone_names)
      
    }
  
  return(depth_zones_stack)
}
