#' Get a set of feature data for an area or planning grid
#'
#' @description This is a wrapper of `get_bathymetry()`, `get_seamounts_buffered()`, `get_knolls()`, `get_geomorphology()`, `get_coral_habitat()`, and `get_enviro_regions()`. See the indvidual functions for details.
#' 
#' @param area_polygon an `sf` polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param planning_grid a `terra::rast()` or `sf` planning grid with the desired resolution and coordinate reference system generated by `get_planning_grid()`. For a raster, values in the planning grid cells should be 1, while all other values are NA
#' @param features a vector of feature names, can include: "bathymetry", "seamounts", "knolls", "geomorphology", "corals", "enviro_regions"
#' @param seamount_buffer `numeric`; the distance from the seamount peak to include in the output. Distance should be in the same units as the area_polygon or planning_grid provided, use e.g. `sf::st_crs(planning_grid, parameters = TRUE)$units_gdal` to check what units your planning grid or area polygon is in (works for raster as well as sf objects)
#' @param bathy_resolution `numeric`; the resolution (in minutes) of data to pull from the ETOPO 2022 Global Relief model. Values less than 1 can only be 0.5 (30 arc seconds) and 0.25 (15 arc seconds)
#' @param antipatharia_threshold `numeric` between 0 and 100; the threshold value for habitat suitability for antipatharia corals to be considered present (default is 22, as defined in Yesson et al., 2017)
#' @param octocoral_threshold `numeric` between 0 and 7; the threshold value for how many species (of 7) should be predicted present in an area for octocorals to be considered present (default is 2)
#' @param enviro_clusters `numeric`; the number of environmental regions to cluster the data into - to be used when a clustering algorithm is not necessary (default is NULL)
#' @param max_enviro_clusters `numeric`; the maximum number of environmental regions to try when using the clustering algorithm (default is 8)
#' @param antimeridian  Does `area_polygon` or `planning_grid` span the antimeridian? If so, this should be set to `TRUE`, otherwise set to `FALSE`. If set to `NULL` (default) the function will try to check if data spans the antimeridian and set this appropriately. 
#'
#' @return If an `area_polygon` is supplied, a list of feature data is returned (will be mixed raster and sf objects). If a `planning_grid` is supplied, a raster stack or `sf` of gridded data is returned, depending on `planning_grid` format.
#' @export
#'
#' @examples
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda", mregions_column = "territory1")
#' # Get a feature data for Bermuda
#' feature_set <- get_features(area_polygon = bermuda_eez)
#' # Get feature data in a planning grid
#' planning_grid <- get_planning_grid(area_polygon = bermuda_eez, projection_crs = '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs', resolution = 5000)
#' # Grab all the data
#' features_gridded <- get_features(planning_grid = planning_grid)

get_features <- function(area_polygon = NULL, planning_grid = NULL, features = c("bathymetry", "seamounts", "knolls", "geomorphology", "corals", "enviro_regions"), seamount_buffer = 30000, bathy_resolution = 1, antipatharia_threshold = 22, octocoral_threshold = 2, enviro_clusters = NULL, max_enviro_clusters = 6, antimeridian = NULL){
  
  if("bathymetry" %in% features) { 
    message("Getting depth zones...")
    bathymetry <- get_bathymetry(area_polygon = area_polygon, planning_grid = planning_grid, resolution = bathy_resolution, antimeridian = antimeridian)
  }
  
  if("seamounts" %in% features) { 
    message("Getting seamount data...")
    seamounts <- get_seamounts_buffered(area_polygon = area_polygon, planning_grid = planning_grid, buffer = seamount_buffer, antimeridian = antimeridian)
  }
  
  if("knolls" %in% features) { 
    message("Getting knoll data...")
    knolls <- get_knolls(area_polygon = area_polygon, planning_grid = planning_grid, antimeridian = antimeridian)
  }
  
  if("geomorphology" %in% features) { 
    message("Getting geomorphology data...")
    suppressMessages({
      geomorphology <- get_geomorphology(area_polygon = area_polygon, planning_grid = planning_grid, antimeridian = antimeridian)
    })
  }
  
  if("corals" %in% features) { 
    message("Getting coral data...")
    suppressMessages({
      corals <- get_coral_habitat(area_polygon = area_polygon, planning_grid = planning_grid, antipatharia_threshold = antipatharia_threshold, octocoral_threshold = octocoral_threshold, antimeridian = antimeridian)
    })
    if(check_raster(corals)){
      message(paste0("|-- Coral data found for ", paste0(gsub("_", " ", names(corals)), collapse = ", ")))
    }else{
      coral_names <- corals %>% 
        sf::st_drop_geometry() %>% 
        names()
    message(paste0("|-- Coral data found for ", paste0(gsub("_", " ", coral_names), collapse = ", ")))
    }
    
  }
  
  if("enviro_regions" %in% features) { 
    message("Getting environmental regions data... This could take several minutes")
    suppressMessages({
      enviro_regions <- get_enviro_regions(area_polygon = area_polygon, planning_grid = planning_grid, show_plots = FALSE, num_clusters = enviro_clusters, max_num_clusters = max_enviro_clusters, antimeridian = antimeridian)
    })
  }
  
  if(check_raster(planning_grid)) { 
    ras_names <- sapply(mget(features), names) %>% 
      unlist(use.names = FALSE)
    
    mget(features) %>% 
      terra::rast() %>% 
      stats::setNames(ras_names)
  } else if(!is.null(planning_grid)) { 
    sf_features <- mget(features)
    
    lapply(sf_features[1:(length(sf_features)-1)], function(x) sf::st_drop_geometry(x)) %>% 
      do.call(cbind, .) %>% 
      cbind(sf_features[[length(sf_features)]]) %>% 
      sf::st_sf()
  } else{
    mget(features)
      
  }
  
} 