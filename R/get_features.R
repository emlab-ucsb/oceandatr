#' Combine feature functions to grab and collate all available data
#'
#' @description This function grabs and collates all available data in an area of interest
#' 
#' @details This is a wrapper function of `get_bathymetry()`, `get_seamounts_buffered()`, `get_knolls()`, `get_geomorphology()`, `get_coral_habitat()`, and `get_enviro_regions()`
#'
#' @param area_polygon an sf polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#' @param features a vector of feature names, can include: "bathymetry", "seamounts", "knolls", "geomorphology", "corals", "enviro_regions"
#' @param seamount_buffer numeric; the distance (in units the same as the planning grid or area polygon) from the seamount peak to include in the output; (default is 30km, but if your planning grid/ area polygon crs is not in units of metres this will need to be changed) only required if "seamounts" is in features
#' @param bathy_resolution numeric; the resolution (in decimal degrees) of data to pull from the ETOPO 2022 Global Relief model (default is 1); only required if "bathymetry" is in features
#' @param antipatharia_threshold numeric between 0 and 7; the threshold value for how many species (of 7) should be predicted present in an area for octocorals to be considered present (default is 2); only required if "corals" is in features
#' @param octocoral_threshold numeric between 0 and 100; the threshold value for habitat suitability for antipatharia corals to be considered present (default is 22, as defined in Yesson et al., 2017); only required if "corals" is in features
#' @param enviro_clusters numeric; the number environmental regions to calculate - to be used when a clustering algorithm is not necessary (default is NULL); only required if "enviro_regions" is in features
#' @param max_enviro_clusters numeric; the maximum number of environmental regions to try when using the clustering algorithm (default is 8); only required if "enviro_regions" is in features
#'
#' @return A raster stack with each layer representing a different feature, or an sf object with each column representing a different feature
#' @export
#'
#' @examples
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda")
#' Get a gridded feature set
#' planning_grid <- get_planning_grid(area_polygon = bermuda_eez, projection_crs = '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs', resolution = 5000)
#' # Grab all the data
#' features <- get_features(planning_grid = planning_grid)

get_features <- function(area_polygon = NULL, planning_grid = NULL, features = c("bathymetry", "seamounts", "knolls", "geomorphology", "corals", "enviro_regions"), seamount_buffer = 30000, bathy_resolution = 1, antipatharia_threshold = 22, octocoral_threshold = 2, enviro_clusters = NULL, max_enviro_clusters = 8){
  
  if("bathymetry" %in% features) { 
    message("Getting depth zones...")
    bathymetry <- get_bathymetry(area_polygon = area_polygon, planning_grid = planning_grid, resolution = bathy_resolution)
  }
  
  if("seamounts" %in% features) { 
    message("Getting seamount data...")
    seamounts <- get_seamounts_buffered(area_polygon = area_polygon, planning_grid = planning_grid, buffer = seamount_buffer)
  }
  
  if("knolls" %in% features) { 
    message("Getting knoll data...")
    knolls <- get_knolls(area_polygon = area_polygon, planning_grid = planning_grid)
  }
  
  if("geomorphology" %in% features) { 
    message("Getting geomorphology data...")
    suppressMessages({
      geomorphology <- get_geomorphology(area_polygon = area_polygon, planning_grid = planning_grid)
    })
  }
  
  if("corals" %in% features) { 
    message("Getting coral data...")
    suppressMessages({
      corals <- get_coral_habitat(area_polygon = area_polygon, planning_grid = planning_grid, antipatharia_threshold = antipatharia_threshold, octocoral_threshold = octocoral_threshold)
    })
    #message(paste0("|-- Coral data found for ", paste0(gsub("_", " ", names(corals)[!grepl("geometry", names(corals))]), collapse = ", ")))
  }
  
  if("enviro_regions" %in% features) { 
    message("Getting environmental regions data... This could take several minutes")
    suppressMessages({
      enviro_regions <- get_enviro_regions(area_polygon = area_polygon, planning_grid = planning_grid, show_plots = FALSE, num_clusters = enviro_clusters, max_num_clusters = max_enviro_clusters)
    })
  }
  
  if(check_raster(planning_grid)) { 
    ras_names <- sapply(mget(features), names) %>% 
      unlist(use.names = FALSE)
    
    mget(features) %>% 
      terra::rast() %>%
      setNames(ras_names)
  } else { 
    sf_features <- mget(features)
    
    lapply(sf_features[1:(length(sf_features)-1)], function(x) sf::st_drop_geometry(x)) %>% 
      do.call(cbind, .) %>% 
      cbind(sf_features[[length(sf_features)]]) %>% 
      sf::st_sf()
  }
  
} 