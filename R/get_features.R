#' Combine feature functions to grab and collate all available data
#'
#' @description This function grabs and collates all available data in an area of interest
#' 
#' @details This is a wrapper function of `get_bathymetry()`, `classify_depths()`, `get_seamounts_buffered()`, `get_knolls()`, `get_geomorphology()`, `get_coral_habitat()`, and `get_enviro_regions()`
#'
#' @param area_polygon an sf polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#' @param features a vector of feature names, can include: "bathymetry", "seamounts", "knolls", "geomorphology", "corals", "enviro_regions"
#' @param seamount_buffer numeric; the distance (in km) from the seamount peak to include in the output (default is 30); only required if "seamounts" is in features
#' @param bathy_resolution numeric; the resolution (in decimal degrees) of data to pull from the ETOPO 2022 Global Relief model (default is 1); only required if "bathymetry" is in features
#' @param antipatharia_threshold numeric between 0 and 7; the threshold value for how many species (of 7) should be predicted present in an area for octocorals to be considered present (default is 2); only required if "corals" is in features
#' @param octocoral_threshold numeric between 0 and 100; the threshold value for habitat suitability for antipatharia corals to be considered present (default is 22, as defined in Yesson et al., 2017); only required if "corals" is in features
#' @param enviro_clusters numeric; the number environmental regions to calculate - to be used when a clustering algorithm is not necessary (default is NULL); only required if "enviro_regions" is in features
#' @param max_enviro_clusters numeric; the maximum number of environmental regions to try when using the clustering algorithm (default is 8); only required if "enviro_regions" is in features
#'
#' @return A raster stack with each layer representing a different feature, or an sf object with each column representing a different feature
#' @export
#'
#' @examples
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda")
#' # Specify projection
#' projection <- 'PROJCS["ProjWiz_Custom_Lambert_Azimuthal", GEOGCS["GCS_WGS_1984", DATUM["D_WGS_1984", SPHEROID["WGS_1984",6378137.0,298.257223563]], PRIMEM["Greenwich",0.0], UNIT["Degree",0.0174532925199433]], PROJECTION["Lambert_Azimuthal_Equal_Area"], PARAMETER["False_Easting",0.0], PARAMETER["False_Northing",0.0], PARAMETER["Central_Meridian",-64.5], PARAMETER["Latitude_Of_Origin",32], UNIT["Meter",1.0]]'
#' # Create planning area
#' bermuda_planning_area <- get_planning_grid(bermuda_eez, projection)
#' # Grab all the data
#' data <- get_features(area_polygon = bermuda_eez, planning_grid = bermuda_planning_area)

get_features <- function(area_polygon, planning_grid, features = c("bathymetry", "seamounts", "knolls", "geomorphology", "corals", "enviro_regions"), seamount_buffer = 30, bathy_resolution = 1, antipatharia_threshold = 22, octocoral_threshold = 2, enviro_clusters = NULL, max_enviro_clusters = 8){
  
  if("bathymetry" %in% features) { 
    message("Grabbing bathymetry data...")
    bathymetry_raster <- get_bathymetry(area_polygon = area_polygon, planning_grid = planning_grid, resolution = bathy_resolution)
    message("Classifying depth groups... This could take several minutes")
    bathymetry <- classify_depths(bathymetry_raster = bathymetry_raster, planning_grid = planning_grid)
  }
  
  if("seamounts" %in% features) { 
    message("Grabbing seamount data...")
    seamounts <- get_seamounts_buffered(area_polygon = area_polygon, planning_grid = planning_grid, buffer_km = seamount_buffer)
  }
  
  if("knolls" %in% features) { 
    message("Grabbing knoll data...")
    knolls <- get_knolls(area_polygon = area_polygon, planning_grid = planning_grid)
  }
  
  if("geomorphology" %in% features) { 
    message("Grabbing geomorphology data...")
    suppressMessages({
      geomorphology <- get_geomorphology(area_polygon = area_polygon, planning_grid = planning_grid)
    })
  }
  
  if("corals" %in% features) { 
    message("Grabbing coral data...")
    suppressMessages({
      corals <- get_coral_habitat(area_polygon = area_polygon, planning_grid = planning_grid, antipatharia_threshold = antipatharia_threshold, octocoral_threshold = octocoral_threshold)
    })
    message(paste0("|-- Coral data found for ", paste0(gsub("_", " ", names(corals)[!grepl("geometry", names(corals))]), collapse = ", ")))
  }
  
  if("enviro_regions" %in% features) { 
    message("Grabbing environmental regions data... This could take several minutes")
    suppressMessages({
      enviro_regions <- get_enviro_regions(area_polygon = area_polygon, planning_grid = planning_grid, show_plots = FALSE, num_clusters = enviro_clusters, max_num_clusters = max_enviro_clusters)
    })
  }
  
  if(class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster")) { 
    for(i in 1:length(features)) { 
      if(i == 1) { 
        features_returned <- eval(as.name(features[i]))
      } else { 
        features_returned <- c(features_returned,eval(as.name(features[i])))
      }
    }
  } else { 
    for(i in 1:length(features)) { 
      if(i == 1) { 
        features_returned <- eval(as.name(features[i]))
      } else { 
        features_returned <- cbind(features_returned, 
                                   eval(as.name(features[i])) %>% 
                                     sf::st_drop_geometry())
      }
    }
    features_returned <- features_returned %>% 
      dplyr::relocate(geometry, .after = last_col())
  }
  
  return(features_returned)
  
} 