#' Get bathymetry data for the area of interest
#'
#' @description This function extracts bathymetry data for the area of interest from the ETOPO 2022 Global Relief model. If data are already downloaded locally, the user can specify the file path of the dataset. See Details for more information.
#' 
#' @details If the user has downloaded data for the area of interest, for example from GEBCO (https://www.gebco.net), they can pass the file path to this function and it will crop and rasterize the data using the supplied planning grid. If no file path is provided, the function will extract bathymetry data for the area from the ETOPO 2022 Global Relief model served by NOAA (https://www.ncei.noaa.gov/products/etopo-global-relief-model).
#'
#' @param area_polygon an sf polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param planning_grid a raster template with the desired resolution and coordinate reference system generated by `get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#' @param bathymetry_data_filepath string; the file path (including file name and extension) where bathymetry raster data are saved locally
#' @param resolution numeric; the resolution (in minutes) of data to pull from the ETOPO 2022 Global Relief model. Values less than 1 can only be 0.5 (30 arc seconds) and 0.25 (15 arc seconds)
#' @param keep logical; whether to save the bathymetry data locally
#' @param path string; the file path where you would like to save bathymetry data
#' @param download_timeout numeric; the maximum number of seconds a query is allowed to run
#'
#' @return A raster of bathymetry for the area of interest, rasterized to the planning grid resolution and CRS if supplied.
#' @export
#'
#' @examples
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda")
#' # Grab bathymetry data
#' bathymetry <- get_bathymetry(area_polygon = bermuda_eez)
get_bathymetry <- function(area_polygon = NULL, planning_grid = NULL, classify_bathymetry = TRUE, above_sea_level_isNA = FALSE, name = "bathymetry", bathymetry_data_filepath = NULL, resolution = 1, keep = FALSE, path = NULL, download_timeout = 300, antimeridian = NULL){

  check_grid_or_polygon(planning_grid, area_polygon)
  
  meth <- if(check_sf(planning_grid)) 'mean' else 'average'
  
  matching_crs <- check_matching_crs(area_polygon, planning_grid, sf::st_crs(4326))
  
  if(!is.null(planning_grid)){
    area_polygon_for_cropping <- planning_grid_to_polygon(planning_grid, matching_crs)
  }else{
    area_polygon_for_cropping <- area_polygon %>% 
      sf::st_geometry() %>% 
      sf::st_as_sf() %>% 
      {if(matching_crs) . else sf::st_transform(., 4326)}
  }
  
  antimeridian <- check_antimeridian(area_polygon_for_cropping)
  
  if(is.null(bathymetry_data_filepath)){
    bathymetry <- get_etopo_bathymetry(area_polygon_for_cropping, resolution = resolution, keep = keep, path = path, download_timeout = download_timeout) %>% 
      data_to_planning_grid(area_polygon, planning_grid, dat = ., meth, name, antimeridian)
  } else{
    bathymetry <- data_to_planning_grid(area_polygon, planning_grid, dat = bathymetry_data_filepath, meth, name, antimeridian) 
    }
  
  if(classify_bathymetry){
    depth_zones <- c("hadopelagic", "abyssopelagic", "bathypelagic", "mesopelagic", "epipelagic" )
    
    bathymetry_cuts <- c(-12000, -6000, -4000, -1000, -200, 10)
    
    #get only the depth zone names needed for this classification
    depth_zone_names <- if(check_raster(bathymetry)) depth_zones[terra::global(bathymetry, min, na.rm=TRUE)[1,1] < bathymetry_cuts[2:6]] else depth_zones[min(bathymetry[[1]]) < bathymetry_cuts[2:6]] 
    
    bathymetry_cuts <- bathymetry_cuts[(6-length(depth_zone_names)):6]
    
    reclass_var <- ifelse(above_sea_level_isNA, NA, 0)
    
    if(check_sf(bathymetry)){
      bathymetry %>% 
        dplyr::mutate(bathymetry = dplyr::case_when(bathymetry >=0 ~ reclass_var,
                                                    .default = as.numeric(bathymetry))) %>% 
        classify_layers(dat_breaks = bathymetry_cuts, classification_names = depth_zone_names) %>% 
        dplyr::select((ncol(.)-1):1) #reorder shallowest to deepest depth zones
    }else{
      bathymetry %>%
        terra::classify(matrix(c(0, 1e4, reclass_var), ncol = 3), include.lowest = TRUE) %>%
        classify_layers(dat_breaks = bathymetry_cuts, classification_names = depth_zone_names) %>% 
        terra::subset(terra::nlyr(.):1) #reorder shallowest to deepest depth zones
    }
    
  }else{
    return(bathymetry)
  }
}
#This function extracts bathymetry data for the area of interest from the ETOPO 2022 Global Relief model, using a script similar to that from `marmap::getNOAA.bathy()`. This is a helper function for get_bathymetry()

get_etopo_bathymetry <- function(aoi, resolution, keep, path, download_timeout){
  b_box <- sf::st_bbox(aoi)
  lon1 = as.numeric(b_box$xmin)
  lon2 = as.numeric(b_box$xmax)
  lat1 = as.numeric(b_box$ymin)
  lat2 = as.numeric(b_box$ymax)
  
  # Expand range a little bit
  lon1 = max(c(-180, lon1-0.5))
  lon2 = min(c(180, lon2+0.5))
  lat1 = max(c(-90, lat1-0.5))
  lat2 = min(c(90, lat2+0.5))
  
  # Quick checks of specified lat/lons and resolution 
  if (lon1 == lon2) 
    stop("The longitudinal range defined by lon1 and lon2 is incorrect")
  if (lat1 == lat2) 
    stop("The latitudinal range defined by lat1 and lat2 is incorrect")
  if (lat1 > 90 | lat1 < -90 | lat2 > 90 | lat2 < -90) 
    stop("Latitudes should have values between -90 and +90")
  if (lon1 < -180 | lon1 > 180 | lon2 < -180 | lon2 > 180) 
    stop("Longitudes should have values between -180 and +180")
  if (resolution < 0) 
    stop("The resolution must be greater than 0")
  
  # Make it so that the antimeridian is generated based on the data itself
  # (make it easier for the user)
  if(lon1 == -180 & lon2 == 180) { antimeridian = TRUE } else { antimeridian = FALSE}
  
  # Tweak bounds if antimeridian 
  if(antimeridian) { 
    suppressMessages({
      aoi_left <- sf::st_crop(sf::st_geometry(aoi), xmin = 0, xmax = 180, ymin = -90, ymax = 90)
      aoi_right <- sf::st_crop(sf::st_geometry(aoi), xmin = -180, xmax = 0, ymin = -90, ymax = 90)
    })
    lon1_left <- max(c(-180, as.numeric(sf::st_bbox(aoi_left)$xmin-0.5)))
    lon2_left <- min(c(180, as.numeric(sf::st_bbox(aoi_left)$xmax)+0.5))
    lon1_right <- max(c(-180, as.numeric(sf::st_bbox(aoi_right)$xmin)-0.5))
    lon2_right <- min(c(180, as.numeric(sf::st_bbox(aoi_right)$xmax)+0.5)) 
  }
  
  #here on copied directly from marmap package
  
  if (resolution < 0.5) {
    resolution <- 0.25
  } else {
    if (resolution < 1) {
      resolution <- 0.5
    }
  }
  if (resolution == 0.25) database <- "27ETOPO_2022_v1_15s_bed_elev"
  if (resolution == 0.50) database <- "27ETOPO_2022_v1_30s_bed"
  if (resolution  > 0.50) database <- "27ETOPO_2022_v1_60s_bed"
  
  if (is.null(path)) 
    path <- "."
  x1 = x2 = y1 = y2 = NULL
  
  if (lon1 < lon2) {
    x1 <- lon1
    x2 <- lon2
  } else {
    x2 <- lon1
    x1 <- lon2
  }
  if (lat1 < lat2) {
    y1 <- lat1
    y2 <- lat2
  } else {
    y2 <- lat1
    y1 <- lat2
  }
  if (antimeridian) {
    # if (x1 == -180 & x2 == 180) {
    #   x1 <- 0
    #   x2 <- 0
    # }
    l1 <- lon1_left
    l2 <- lon2_left
    l3 <- lon1_right
    l4 <- lon2_right
    ncell.lon.left <- (l2 - l1) * 60/resolution
    ncell.lon.right <- (l4 - l3) * 60/resolution
    ncell.lat <- (y2 - y1) * 60/resolution
    if ((ncell.lon.left + ncell.lon.right) < 2 & ncell.lat < 
        2) 
      stop("It's impossible to fetch an area with less than one cell. Either increase the longitudinal and longitudinal ranges or the resolution (i.e. use a smaller res value)")
    if ((ncell.lon.left + ncell.lon.right) < 2) 
      stop("It's impossible to fetch an area with less than one cell. Either increase the longitudinal range or the resolution (i.e. use a smaller resolution value)")
    if (ncell.lat < 2) 
      stop("It's impossible to fetch an area with less than one cell. Either increase the latitudinal range or the resolution (i.e. use a smaller resolution value)")
  } else {
    ncell.lon <- (x2 - x1) * 60/resolution
    ncell.lat <- (y2 - y1) * 60/resolution
    if (ncell.lon < 2 & ncell.lat < 2) 
      stop("It's impossible to fetch an area with less than one cell. Either increase the longitudinal and longitudinal ranges or the resolution (i.e. use a smaller res value)")
    if (ncell.lon < 2) 
      stop("It's impossible to fetch an area with less than one cell. Either increase the longitudinal range or the resolution (i.e. use a smaller resolution value)")
    if (ncell.lat < 2) 
      stop("It's impossible to fetch an area with less than one cell. Either increase the latitudinal range or the resolution (i.e. use a smaller resolution value)")
  }
  fetch <- function(x1, y1, x2, y2, ncell.lon, ncell.lat) {
    ncell.lon <- floor(ncell.lon)
    ncell.lat <- floor(ncell.lat)
    x1 <- round(x1, 1)
    x2 <- round(x2, 1)
    y1 <- round(y1, 1)
    y2 <- round(y2, 1)
    
    #increase timeout for download which is 60s by default; too short time to download largers files
    options(timeout = max(download_timeout, getOption("timeout")))
    
    # message(paste0("x1 = ", x1, " y1 = ", y1, " x2 = ", x2, " y2 = ", y2, " ncell.lon = ", ncell.lon, " ncell.lat = ", ncell.lat, "\n"))
    WEB.REQUEST <- paste0("https://gis.ngdc.noaa.gov/arcgis/rest/services/DEM_mosaics/DEM_all/ImageServer/exportImage?bbox=", x1, ",", y1, ",", x2, ",", y2, "&bboxSR=4326&size=", ncell.lon, ",", ncell.lat,"&imageSR=4326&format=tiff&pixelType=F32&interpolation=+RSP_NearestNeighbor&compression=LZ77&renderingRule={%22rasterFunction%22:%22none%22}&mosaicRule={%22where%22:%22Name=%", database, "%27%22}&f=image")
    filename <- gsub("[.]", "", paste(x1, x2, y1, y2, sep = "_"))
    download.file(url = WEB.REQUEST, destfile = paste0(filename, "_tmp.tif"), mode = "wb", quiet = TRUE)
    dat <- suppressWarnings(try(terra::rast(paste0(filename, "_tmp.tif")), silent = TRUE))
    return(dat)
  }
  
  # Naming the file 
  if (antimeridian) {
    FILE <- paste0("marmap_coord_", x1, ";", y1, ";", x2, 
                   ";", y2, "_res_", resolution, "_anti", ".grd")
  } else {
    FILE <- paste0("marmap_coord_", x1, ";", y1, ";", x2, 
                   ";", y2, "_res_", resolution, ".grd")
  }
  if (FILE %in% list.files(path = path)) {
    message("File already exists ; loading \'", FILE, "\'", 
            sep = "")
    existing.bathy <- terra::rast(file.path(path, FILE))
    return(existing.bathy)
  } else { # otherwise, fetch it from the NOAA server
    if (antimeridian) {
      # message("Querying NOAA database ...")
      message("This may take seconds to minutes, depending on grid size\n")
      left <- fetch(l1, y1, l2, y2, ncell.lon.left, ncell.lat)
      right <- fetch(l3, y1, l4, y2, ncell.lon.right, ncell.lat)
      if (is(left, "try-error") | is(right, "try-error")) {
        stop("The NOAA server cannot be reached\n")
      } else {
        # message("Got data crossing antimeridian")
        # resample so both are the same exact res (they're a little off)
        left <- terra::resample(left, 
                                terra::rast(ymin = y1, ymax = y2, 
                                            xmin = lon1_left, xmax = lon2_left, 
                                            resolution = terra::res(right)))
        bath <- terra::merge(left, right) %>%
          setNames("bathymetry")
        # left <- marmap::as.bathy(raster::raster(left))
        # left <- left[-nrow(left), ]
        # right <- marmap::as.bathy(raster::raster(right))
        # rownames(right) <- as.numeric(rownames(right)) +
        #  360
        # bath2 <- rbind(left, right)
        # class(bath2) <- "bathy"
        # bath <- marmap::as.xyz(bath2)
        
      }
    } else {
      # message("Querying NOAA database ...")
      message("This may take seconds to minutes, depending on grid size")
      bath <- fetch(x1, y1, x2, y2, ncell.lon, ncell.lat) %>% 
        setNames("bathymetry")
      
      if (is(bath, "try-error")) {
        stop("The NOAA server cannot be reached\n")
      } else{
        "Got data"
      }
    }
    
    if(!terra::inMemory(bath)){
      terra::set.values(bath)
    }
    
    if (keep) {
      terra::writeRaster(bath, file = file.path(path, FILE), overwrite =FALSE)
    }
    #clean up the temp file
    file.remove(list.files(pattern = "tmp.tif"))
    return(bath)
  }
  
}