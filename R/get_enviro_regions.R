#' Create environmental regions for area of interest
#'
#' @description This function extracts environmental data from Bio-Oracle for the area of interest and calculates environmental regions using a clustering algorithm. Details are described in Magris et al. (2020):https://doi.org/10.1111/ddi.13183
#' 
#' @details Environmental data are:
#' \itemize{
#' \item Carbon phytoplankton biomass (mean)
#' \item Chlorophyll concentration (mean)
#' \item Dissolved oxygen concentration (mean)
#' \item Nitrate concentration (mean)
#' \item pH (mean)
#' \item Phosphate concentration (mean)
#' \item Primary production (mean)
#' \item Sea surface saliinity (mean)
#' \item Sea surface temperature (max)
#' \item Sea surface temperature (mean)
#' \item Sea surface temperature (min)
#' \item Silicate concentration (mean)
#' }
#'  
#' @param area_polygon an sf polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#' @param show_plots logical; whether to show a series of paneled boxplots for each environmental variable in each environmental region (default is TRUE)
#' @param raw_data logical; whether to only download the raw data and not proceed to calculating environmental regions (default is FALSE)
#' @param num_clusters numeric; the number environmental regions to calculate - to be used when a clustering algorithm is not necessary (default is NULL)
#' @param max_num_clusters numeric; the maximum number of environmental regions to try when using the clustering algorithm (default is 8)
#'
#' @return a raster stack with each layer representing a unique environmental region (if `raw_data == FALSE`); a raster stack with each layer representing a dataset pulled from Bio-Oracle (if `raw_data == TRUE`)
#' @export
#'
#' @examples
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda")
#' # Just grab environmental data in the area of interest
#' get_enviro_regions(bermuda_eez, raw_data = TRUE)
#' # Calculate three environmental regions from the data
#' get_enviro_regions(bermuda_eez, num_clusters = 3)

get_enviro_regions <- function(area_polygon = NULL,  planning_grid = NULL, raw_data = FALSE, show_plots = TRUE, num_clusters = NULL, max_num_clusters = 8, antimeridian = NULL){
  
  check_grid_or_polygon(planning_grid, area_polygon)
  
  # Add error for cluster numbers
  if(!is.null(num_clusters)) {
    if(num_clusters < 1){ stop("num_clusters must be greater than 1 or NULL")}
    if(!all.equal(num_clusters, round(num_clusters))){ stop("num_clusters must be a whole number")}} 
  if(max_num_clusters < 1) { 
    stop("max_num_clusters must be greater than 1")}
  if(!all.equal(max_num_clusters, round(max_num_clusters))){ stop("max_num_clusters must be a whole number")}
  
  matching_crs <- check_matching_crs(area_polygon, planning_grid, sf::st_crs(4326))
  
  area_polygon_for_cropping <- area_polygon_lonlat(area_polygon, planning_grid, matching_crs)
  
  enviro_data <- get_enviro_data(area_polygon = area_polygon, planning_grid = planning_grid, antimeridian = antimeridian)
  
 if(raw_data){
   enviro_data
  }
  else{
    
    df_for_clustering <- if(check_sf(enviro_data)) sf::st_drop_geometry(enviro_data) else terra::as.data.frame(enviro_data, na.rm = NA)
    
   if(is.null(num_clusters)){
      message("This could several minutes")
      #setting index = "all" results in large memory usage and long runtime (I haven't run to completion after >1hr), for the moment, setting the index to "hartigan" which is the same algorithm (Hartigan-Wong) used by the kmeans() function used below
     
      clust_result <- NbClust::NbClust(data = df_for_clustering, method = "kmeans", max.nc = max_num_clusters,  index = "hartigan")
      
      clust_partition <- clust_result$Best.partition
      }else {
        #k-means clustering for specific number of clusters
        return(df_for_clustering)
        clust_result <- kmeans(x = df_for_clustering, centers = num_clusters, nstart = 10)
      
        clust_partition <- clust_result$cluster
      }
    
    if(show_plots) enviro_regions_boxplot(clust_partition, df_for_clustering)
    
    if(check_sf(enviro_data)){
      enviro_region_cols <- model.matrix(~ as.factor(clust_partition) - 1) %>% 
        as.data.frame() %>%   
        setNames(paste0("enviro_region_", 1:ncol(.)))
      
      sf::st_geometry(ber_enviro_data_sf_pu) %>% 
        sf::st_as_sf() %>% 
        cbind(enviro_region_cols) 
    }else{
      #create environmental regions raster, filled with NAs to start with
      enviro_regions <- terra::rast(enviro_data, nlyrs=1, vals = NA, names = "enviro_region")
      
      #set cluster ids in raster - subset for only raster values that are non-NA
      enviro_regions[as.numeric(names(clust_partition))] <- clust_partition
      
      enviro_regions %>% 
        terra::segregate(other=NA) %>% 
        setNames(paste0("enviro_region_", names(.)))
    }
  }
}

get_enviro_data <- function(area_polygon = NULL, planning_grid = NULL, antimeridian){
  bio_oracle_data <- list.files(system.file("extdata", "bio_oracle", package = "offshoredatr", mustWork = TRUE), full.names = TRUE) %>% 
    terra::rast()
  
  meth <- if(check_sf(planning_grid)) 'mean' else 'average'
  
    data_to_planning_grid(area_polygon = area_polygon, planning_grid = planning_grid, dat = bio_oracle_data, meth = meth, name = names(bio_oracle_data), antimeridian = antimeridian) 
}

enviro_regions_boxplot <- function(enviro_region, enviro_data){
  #compare values in each environmental region
  enviro_regions_df <- cbind(enviro_region, enviro_data) 

  par(mfrow = c(3,4))
  for (i in 2:ncol(enviro_regions_df)) {
    eval(parse(text = paste0("boxplot(`", colnames(enviro_regions_df[i]), "` ~ enviro_region, data = enviro_regions_df, col = palette.colors(n = ", max(enviro_region), ", palette = 'Dark2'))")))
  }
  par(mfrow = c(1,1))
}
