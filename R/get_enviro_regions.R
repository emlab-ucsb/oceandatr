#' Create environmental regions for area of interest
#'
#' @description This function extracts environmental data from Bio-Oracle for the area of interest and calculates environmental regions using a clustering algorithm. Details are described in Magris et al. (2020):https://doi.org/10.1111/ddi.13183
#' 
#' @details Environmental variables that are extracted include: mean carbon phytoplankton biomass, mean chlorophyll concentration, mean dissolved oxygen concentration, mean nitrate concentration, mean pH, mean phosphate concentration, mean primary production, mean sea surface salinity, maximum sea surface temperature, mean sea surface temperature, mininum sea surface temperature, and mean silicate concentration.
#'  
#' @param area_polygon an sf polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param planning_grid a raster template with the desired resolution and coordinate reference system generated by `get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#' @param show_plots logical; whether to show a series of paneled boxplots for each environmental variable in each environmental region (default is TRUE)
#' @param raw_data logical; whether to only download the raw data and not proceed to calculating environmental regions (default is FALSE)
#' @param num_clusters numeric; the number environmental regions to calculate - to be used when a clustering algorithm is not necessary (default is NULL)
#' @param max_num_clusters numeric; the maximum number of environmental regions to try when using the clustering algorithm (default is 8)
#'
#' @return a raster stack with each layer representing a unique environmental region (if `raw_data == FALSE`); a raster stack with each layer representing a dataset pulled from Bio-Oracle (if `raw_data == TRUE`)
#' @export
#'
#' @examples
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda")
#' # Just grab environmental data in the area of interest
#' get_enviro_regions(bermuda_eez, raw_data = TRUE)
#' # Calculate three environmental regions from the data
#' get_enviro_regions(bermuda_eez, num_clusters = 3)

get_enviro_regions <- function(area_polygon,  planning_grid = NULL, show_plots = TRUE, raw_data = FALSE, num_clusters = NULL, max_num_clusters = 8){
  
  # Add repeated errors for area_polygon and planning_grid (these are present for nearly all functions)
  if(!(class(area_polygon)[1] == "sf")) { 
    stop("area_polygon must be an sf object")}
  
  if(!is.null(planning_grid) & !(class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster", "sf"))) { 
    stop("planning_grid must be a raster or sf object")}
  
  # Add error for cluster numbers
  if(!is.null(num_clusters)) {
    if(num_clusters < 1){ stop("num_clusters must be greater than 1 or NULL")}
    if(!all.equal(num_clusters, round(num_clusters))){ stop("num_clusters must be a whole number")}} 
  if(max_num_clusters < 1) { 
    stop("max_num_clusters must be greater than 1")}
  if(!all.equal(max_num_clusters, round(max_num_clusters))){ stop("max_num_clusters must be a whole number")}
  
  enviro_data <- get_enviro_data(area_polygon, planning_grid)
  
 if(raw_data){
   return(enviro_data)
  }
  else{
    if(is.null(num_clusters)){
      
      message("This could several minutes")
      #setting index = "all" results in large memory usage and long runtime (I haven't run to completion after >1hr), for the moment, setting the index to "hartigan" which is the same algorithm (Hartigan-Wong) used by the kmeans() function used below
      clust_results <- NbClust::NbClust(data = terra::as.data.frame(enviro_data, na.rm = NA), method = "kmeans", max.nc = max_num_clusters,  index = "hartigan")
      
      #create environmental regions raster, filled with NAs to start with
      enviro_regions <- terra::rast(enviro_data, nlyrs=1, vals = NA, names = "enviro_region")
      
      #set cluster ids in raster - subset for only raster values that are non-NA
      enviro_regions[as.numeric(names(clust_results$Best.partition))] <- clust_results$Best.partition
      
      if(show_plots){
        enviro_regions_boxplot(enviro_regions, enviro_data)
      }
      
      if(is.null(planning_grid) | class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster")){
        enviro_regions <- enviro_regions %>% 
          terra::segregate(other=NA)
      } else { 
        enviro_regions <- enviro_regions %>%
          terra::as.polygons(dissolve = FALSE) %>%
          sf::st_as_sf() %>%
          sf::st_join(planning_grid, .) %>% 
          dplyr::filter(!is.na(enviro_region)) %>% 
          dplyr::mutate(enviro_region = paste0("environmental_region_", enviro_region), 
                        value = 1) %>% 
          tidyr::pivot_wider(names_from = "enviro_region", values_from = "value", values_fn = max) 
      } 
      
      return(enviro_regions)
    }
    else{
      
      #k-means clustering for specific number of clusters
      kmean_result <- kmeans(x = terra::as.data.frame(enviro_data, na.rm = NA), centers = num_clusters, nstart = 10)
      
      #create clustered raster
      enviro_regions <- terra::rast(enviro_data, nlyrs=1, vals = NA, names = "enviro_region")
      
      #set cluster ids in raster - subset for only raster values that are non-NA
      enviro_regions[as.numeric(names(kmean_result$cluster))] <- kmean_result$cluster
      
      if(show_plots){
        enviro_regions_boxplot(enviro_regions, enviro_data)
      }
      
      if(is.null(planning_grid) | class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster")){
        enviro_regions <- enviro_regions %>% 
          terra::segregate(other=NA)
      } else { 
        enviro_regions <- enviro_regions %>%
          terra::as.polygons(dissolve = FALSE) %>%
          sf::st_as_sf() %>%
          sf::st_join(planning_grid, .) %>% 
          dplyr::filter(!is.na(enviro_region)) %>% 
          dplyr::mutate(enviro_region = paste0("environmental_region_", enviro_region), 
                        value = 1) %>% 
          tidyr::pivot_wider(names_from = "enviro_region", values_from = "value", values_fn = max) 
      } 
      
      return(enviro_regions)
    }
  }
}

get_enviro_data <- function(area_polygon, planning_grid){
  tif_list <- list.files(system.file("extdata", "bio_oracle", package = "offshoredatr", mustWork = TRUE), full.names = TRUE)
  
  enviro_data <- terra::rast(tif_list) %>% 
    terra::crop(area_polygon, mask = TRUE)
  
  if(is.null(planning_grid)){
    message("Data are not projected")
  } 
  else if(class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster")){
    enviro_data <- enviro_data %>% 
      terra::project(planning_grid) %>% 
      terra::mask(planning_grid)
  } else {
    enviro_data <- enviro_data %>% 
      terra::project(terra::crs(planning_grid)) %>% 
      terra::mask(planning_grid)
  }
  return(enviro_data)
}

enviro_regions_boxplot <- function(enviro_regions, enviro_data){
  #compare values in each environmental region
  enviro_regions_df <- c(enviro_regions, enviro_data) %>% 
    terra::as.data.frame() 
  
  par(mfrow = c(3,4))
  for (i in 2:ncol(enviro_regions_df)) {
    eval(parse(text = paste0("boxplot(`", colnames(enviro_regions_df[i]), "` ~ enviro_region, data = enviro_regions_df, col = palette.colors(n = ", max(enviro_regions_df$enviro_region), ", palette = 'Dark2'))")))
  }
  par(mfrow = c(1,1))
}