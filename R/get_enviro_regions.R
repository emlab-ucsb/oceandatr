#' Create environmental regions for area of interest
#'
#' @description This function gets [Bio-Oracle](https://bio-oracle.org/) environmental data for the area of interest or planning grid and creates environmental regions using k-means clustering. The idea for this comes from Magris et al. [2020](https://doi.org/10.1111/ddi.13183). The number of environmental regions can be specified directly, using `num_clusters`, but the function will also find the 'optimal' number of clusters using the `NbClust()` from the `NbClust` package.
#' 
#' @details The environmental data used in the clustering, obtained from Bio-Oracle are:
#' \itemize{
#' \item Carbon phytoplankton biomass (mean)
#' \item Chlorophyll concentration (mean)
#' \item Dissolved oxygen concentration (mean)
#' \item Nitrate concentration (mean)
#' \item pH (mean)
#' \item Phosphate concentration (mean)
#' \item Primary production (mean)
#' \item Sea surface saliinity (mean)
#' \item Sea surface temperature (max)
#' \item Sea surface temperature (mean)
#' \item Sea surface temperature (min)
#' \item Silicate concentration (mean)
#' }
#' 
#' When the number of planning units/ cells for clustering exceeds ~ 10,000, the amount of computer memory required to find the optimal number of clusters using `NbClust::NbClust()` exceeds 10GB, so repeated sampling is used to find a consensus number of clusters. Sensible defaults are provided, namely `sample_size = 5000`, `num_samples = 5`, `max_num_clusters = 6` but can be customised if desired, though see the parameter descriptions below for some words of warning. Parallel processing is offered by specifying `num_cores` >1 (must be an integer), though the package `parallel` must be installed (it is included in most R installations). To find the number of available cores `parallel::detectCores()`.
#'  
#' @param area_polygon an `sf` polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param planning_grid a `terra::rast()` or `sf` planning grid with the desired resolution and coordinate reference system generated by `get_planning_grid()`. For a raster, values in the planning grid cells should be 1, while all other values are NA
#' @param show_plots `logical`; whether to show boxplots for each environmental variable in each environmental region (default is TRUE)
#' @param raw_data `logical`; whether to only return the raw Bio-Oracle environmental data and not proceed to calculating environmental regions (default is FALSE)
#' @param num_clusters `numeric`; the number of environmental regions to cluster the data into - to be used when a clustering algorithm is not necessary (default is NULL)
#' @param max_num_clusters `numeric`; the maximum number of environmental regions to try when using the clustering algorithm (default is 6)
#' @param antimeridian  Does `area_polygon` or `planning_grid` span the antimeridian? If so, this should be set to `TRUE`, otherwise set to `FALSE`. If set to `NULL` (default) the function will try to check if data spans the antimeridian and set this appropriately. 
#' @param sample_size `numeric`; default is 5000. Larger sample sizes will quickly consume memory (>10GB) so should be used with caution.
#' @param num_samples `numeric`; default is 5, which resulted in good consensus on the optimal number of clusters in testing.
#' @param num_cores `numeric`; default 1. Multi-core sampling is supported if the package `parallel` is installed, but be aware than increasing the number of cores will also increase the memory required.
#' @param custom_seed `numeric`; default `1234`, but a custom seed can be supplied if desired.
#'
#' @return If an `area_polygon` is supplied, a raster stack of environmental regions, or Bio-Oracle data if `raw_data = TRUE`, is returned. If a `planning_grid` is supplied, a raster stack or `sf` of gridded environmental regions,  or Bio-Oracle data if `raw_data = TRUE`, is returned depending on `planning_grid` format.
#'
#' @export
#'
#' @examples
#' # Get EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda")
#' # Get the Bio-Oracle environmental data in the area of interest
#' enviro_data <- get_enviro_regions(area_polygon = bermuda_eez, raw_data = TRUE)
#' # Create three environmental regions for a planning grid
#' planning_grid <- get_planning_grid(area_polygon = bermuda_eez, projection_crs = '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs', resolution = 5000)
#' enviro_regions <- get_enviro_regions(planning_grid = planning_grid, num_clusters = 3)

get_enviro_regions <- function(area_polygon = NULL,  planning_grid = NULL, raw_data = FALSE, show_plots = TRUE, num_clusters = NULL, max_num_clusters = 6, antimeridian = NULL, sample_size = 5000, num_samples = 5, num_cores = 1, custom_seed = 1234){
  
  check_grid_or_polygon(planning_grid, area_polygon)
  
  # Add error for cluster numbers
  if(!is.null(num_clusters)) {
    if(num_clusters < 1){ stop("num_clusters must be greater than 1 or NULL")}
    if(!all.equal(num_clusters, round(num_clusters))){ stop("num_clusters must be a whole number")}} 
  if(max_num_clusters < 1) { 
    stop("max_num_clusters must be greater than 1")}
  if(!all.equal(max_num_clusters, round(max_num_clusters))){ stop("max_num_clusters must be a whole number")}
  
  if(num_cores > 1 & !requireNamespace("parallel", quietly = TRUE)) message("The 'parallel' package is required to use multiple cores. This function will continue to run but only use 1 core.")
  
  matching_crs <- check_matching_crs(area_polygon, planning_grid, sf::st_crs(4326))
  
  area_polygon_for_cropping <- area_polygon_lonlat(area_polygon, planning_grid, matching_crs)
  
  enviro_data <- get_enviro_data(area_polygon = area_polygon, planning_grid = planning_grid, antimeridian = antimeridian)
  
 if(raw_data){
   enviro_data
  }
  else{
    
    df_for_clustering <- if(check_sf(enviro_data)) sf::st_drop_geometry(enviro_data) %>% as.data.frame() %>% .[stats::complete.cases(.),] else terra::as.data.frame(enviro_data, na.rm = NA)
    
    if(sample_size > nrow(df_for_clustering)) sample_size <- nrow(df_for_clustering)
    
   if(is.null(num_clusters)){
      message("This could take several minutes")
      #setting index = "all" results in large memory usage and long runtime (I haven't run to completion after >1hr), for the moment, setting the index to "hartigan" which is the same algorithm (Hartigan-Wong) used by the kmeans() function used below
     set.seed(custom_seed)
     
     n_df_rows <- nrow(df_for_clustering)
     
     df_sample <- lapply(rep(sample_size, num_samples), function(x) df_for_clustering[sample.int(n_df_rows, x),])
     
     if(num_cores > 1 & requireNamespace("parallel", quietly = TRUE)){
       
       if(Sys.info()["sysname"]=="Windows"){
         cluster <- parallel::makePSOCKcluster(num_cores)
         best_no_clusts <- parallel::parLapply(cluster, df_sample, function(x) NbClust::NbClust(data = x, method = "kmeans", max.nc = max_num_clusters,  index = "hartigan") %>% .[[2]] %>% .["Number_clusters"]) %>% 
           unlist()
         
       }else{
         best_no_clusts <- parallel::mclapply(df_sample, function(x) NbClust::NbClust(data = x, method = "kmeans", max.nc = max_num_clusters,  index = "hartigan") %>% .[[2]] %>% .["Number_clusters"], mc.cores = num_cores) %>% 
           unlist()
       }
     }else{
       best_no_clusts <- sapply(df_sample, function(x) NbClust::NbClust(data = x, method = "kmeans", max.nc = max_num_clusters,  index = "hartigan") %>% .[[2]] %>% .["Number_clusters"])
     }
     uniq_values_clusters <- unique(best_no_clusts)
     
     num_clusters <- uniq_values_clusters[which.max(tabulate(match(best_no_clusts, uniq_values_clusters)))]
     
      }
    #k-means clustering for specific number of clusters
    clust_result <- stats::kmeans(x = df_for_clustering, centers = num_clusters, nstart = 10)
    clust_partition <- clust_result$cluster
    
    if(show_plots) {
      enviro_regions_boxplot(clust_partition, df_for_clustering)
      enviro_regions_pca(clust_partition, df_for_clustering)
    }
    
    if(check_sf(enviro_data)){
      enviro_region_cols <- stats::model.matrix(~ as.factor(clust_partition) - 1) %>% 
        as.data.frame() %>%   
        stats::setNames(paste0("enviro_region_", 1:ncol(.))) %>% 
        dplyr::mutate(row_id = as.numeric(names(clust_partition)))
      
      sf::st_geometry(enviro_data) %>% 
        sf::st_as_sf() %>% 
        dplyr::mutate(row_id = 1:nrow(.)) %>% 
        dplyr::left_join(enviro_region_cols, by = dplyr::join_by(row_id)) %>% 
        dplyr::select(-row_id)
    }else{
      #create environmental regions raster, filled with NAs to start with
      enviro_regions <- terra::rast(enviro_data, nlyrs=1, vals = NA, names = "enviro_region")
      
      #set cluster ids in raster - subset for only raster values that are non-NA
      enviro_regions[as.numeric(names(clust_partition))] <- clust_partition
      
      enviro_regions %>% 
        terra::segregate(other=NA) %>% 
        stats::setNames(paste0("enviro_region_", names(.)))
    }
  }
}

get_enviro_data <- function(area_polygon = NULL, planning_grid = NULL, antimeridian){
  bio_oracle_data <- list.files(system.file("extdata", "bio_oracle", package = "oceandatr", mustWork = TRUE), full.names = TRUE) %>% 
    terra::rast()
  
  meth <- if(check_sf(planning_grid)) 'mean' else 'average'
  
    data_to_planning_grid(area_polygon = area_polygon, planning_grid = planning_grid, dat = bio_oracle_data, meth = meth, name = names(bio_oracle_data), antimeridian = antimeridian) 
}

enviro_regions_boxplot <- function(enviro_region, enviro_data){
  #compare values in each environmental region
  enviro_regions_df <- cbind(enviro_region, enviro_data) 

  graphics::par(mfrow = c(3,4))
  for (i in 2:ncol(enviro_regions_df)) {
    eval(parse(text = paste0("boxplot(`", colnames(enviro_regions_df[i]), "` ~ enviro_region, data = enviro_regions_df, col = palette.colors(n = ", max(enviro_region), ", palette = 'Dark2'))")))
  }
  graphics::par(mfrow = c(1,1))
}

enviro_regions_pca <- function(enviro_region, enviro_data){
  pca_df <- stats::prcomp(enviro_data, scale. = TRUE, center = TRUE) %>% 
    .[["x"]] %>% 
    as.data.frame()

  pca_df$enviro_region <- enviro_region
  
  plot(x = pca_df$PC1, y = pca_df$PC2, col = pca_df$enviro_region, xlab = "PC1", ylab = "PC2", pch = 4, cex = 0.6)
  graphics::legend("bottomright", legend = unique(pca_df$enviro_region), col = unique(pca_df$enviro_region), pch = 4, cex = 1, title = "Enviro region")
}
