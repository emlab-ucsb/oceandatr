#' Get geomorphology for an area of interest or planning grid
#' 
#' @description This function gets geomorpholgical data within an area polygon or planning grid depending on which is supplied
#' 
#' @details Geomorphological features are from the [Harris et al. 2014](https://doi.org/10.1016/j.margeo.2014.01.011) dataset, available at: https://www.bluehabitats.org. The features included are limited to those listed in [Cecarelli et al. 2021](https://doi.org/10.3389/fmars.2021.634574) Table 5.
#'
#' @param area_polygon an `sf` polygon or multipolygon object of the area of interest (e.g., a country's EEZ)
#' @param spatial_grid a `terra::rast()` or `sf` planning grid with the desired resolution and coordinate reference system generated by `get_grid()`. For a raster, values in the planning grid cells should be 1, while all other values are NA
#' @param antimeridian Does `area_polygon` or `spatial_grid` span the antimeridian? If so, this should be set to `TRUE`, otherwise set to `FALSE`. If set to `NULL` (default) the function will try to check if data spans the antimeridian and set this appropriately.
#'
#' @return If an `area_polygon` is supplied, an `sf` object with each row a different geomorphological feature. If a `spatial_grid` is supplied, a raster stack of geomorphological features or `sf` object with a geomorphological feature in each column is returned, depending on `spatial_grid` format.
#' @export
#'
#' @examples
#' # Grab EEZ data first 
#' bermuda_eez <- get_area(area_name = "Bermuda", mregions_column = "territory1")
#' # Get geomorphology for the EEZ
#' geomorphology <- get_geomorphology(area_polygon = bermuda_eez)
#' # Get geomorphological features in spatial_grid
#' planning_grid <- get_grid(area_polygon = bermuda_eez, projection_crs = '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs', resolution = 5000)
#' geomorph_gridded <- get_geomorphology(spatial_grid = planning_grid)
get_geomorphology <- function(area_polygon = NULL, spatial_grid = NULL, antimeridian = NULL){
  
  check_grid_or_polygon(spatial_grid, area_polygon)
  
  geomorph_file_paths <- system.file("extdata/geomorphology", package = "oceandatr") %>% 
  list.files() %>% 
  system.file("extdata/geomorphology", ., package = "oceandatr")

  geomorph_data <- list()
  
  meth <- if(check_raster(spatial_grid)) 'near' else 'mode'

  suppressMessages({sf::sf_use_s2(FALSE)})
  
  for (i in 1:length(geomorph_file_paths)) {
    feature_name <- gsub(pattern =  ".rds", replacement =  "", basename(geomorph_file_paths[i]))
    
    geomorph_layer <- geomorph_file_paths[i] %>% 
      readRDS() 
    suppressMessages({
      suppressWarnings({
        geomorph_data[[i]] <- get_data_in_grid(area_polygon = area_polygon, spatial_grid = spatial_grid, dat = geomorph_layer, meth = meth, name = feature_name, antimeridian = antimeridian)
        })
    })
  }
  
  suppressMessages({sf::sf_use_s2(TRUE)})
 
  if(!is.null(area_polygon)){
    do.call(rbind, geomorph_data) %>% 
      sf::st_cast(to = "MULTIPOLYGON")
  } else if(check_raster(geomorph_data[[1]])){
    geomorph_ras <- terra::rast(geomorph_data)
    
    na_index <- is.na(terra::minmax(geomorph_ras)[1,])
    if(all(na_index == TRUE)){
      stop("No data present in the planning grid")
    }else geomorph_ras[[!na_index]]
  }else{ #sf planning grid case
    non_zero_index <- (sapply(geomorph_data, function(x) sum(x[[1]], na.rm = TRUE)) >0)
    if(all(non_zero_index == FALSE)){
      stop("No data present in the planning grid")
    }else{
      geomorph_data <- geomorph_data[non_zero_index] 
      
      lapply(geomorph_data[1:(length(geomorph_data)-1)], function(x) sf::st_drop_geometry(x)) %>% 
        do.call(cbind, .) %>% 
        cbind(geomorph_data[[length(geomorph_data)]]) %>% 
        sf::st_sf()
    }
  }
}
